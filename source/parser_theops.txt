================================================================================
                    PASCAL-P6 PARSER THEORY OF OPERATIONS
================================================================================

                                  Overview
                                  --------

The Pascal-P6 parser (parser.pas) is a syntax follower derived from the full
Pascal-P6 compiler (pcom.pas) with code generation stripped out. It performs
lexical analysis, parsing, and semantic analysis without producing any output
code. This makes it useful as a base for tools that need to understand Pascal
source without compiling it, such as:

  - p2c: Pascal to C translator
  - Syntax checkers and linters
  - Documentation generators
  - Code analysis tools

The parser is approximately 8200 lines of Pascal and shares the same symbol
table management, scoping rules, and identifier handling as the full compiler.

================================================================================
                              RELATIONSHIP TO PCOM
================================================================================

parser.pas is pcom.pas with these sections removed:

  - P-code generation procedures (gen0, gen1, gen2, etc.)
  - Code generation calls within parsing procedures
  - P-code output file handling
  - Instruction-specific logic

What remains is:

  - Complete lexical analyzer (insymbol)
  - Complete recursive descent parser
  - Full symbol table management
  - Type checking and semantic analysis
  - Error handling and recovery
  - Memory management (recycling system)

Any changes to symbol table handling, scoping, or identifier management in
pcom.pas should be mirrored in parser.pas and vice versa.

================================================================================
                           CORE DATA STRUCTURES
================================================================================

Identifier Records (ctp):
-------------------------
Each declared identifier is stored in a variant record:

  ctp = ^identifier;
  identifier = record
    name: strvsp;           { identifier name string }
    llink, rlink: ctp;      { binary search tree links }
    idtype: stp;            { pointer to type structure }
    refer: boolean;         { was this identifier referenced? }
    keep: boolean;          { prevent disposal in putnams? }
    klass: idclass;         { types, konst, vars, field, proc, func, alias }
    { ... class-specific variant fields }
  end;

The `klass` field determines the variant:
  - types: Type identifier
  - konst: Constant identifier
  - vars: Variable identifier
  - field: Record field identifier
  - proc/func: Procedure/function identifier
  - alias: Reference to identifier in outer scope

The Alias Class:
----------------
When an identifier from an outer scope is referenced within a nested procedure,
an alias record is created and inserted into the current scope's symbol table.
The alias contains:

  alias: (actid: ctp)       { pointer to the actual identifier }

The alias allows local lookup to find outer-scope identifiers. Key points:
  - The alias shares the name pointer with the original: lcp1^.name := lcp^.name
  - The alias is entered into the current scope's BST
  - When the scope ends, the alias is disposed but the original remains

Display (Scope Stack):
----------------------
The display array manages lexical scopes:

  display: array [disprange] of disprec;

  disprec = record
    fname: ctp;             { root of identifier BST for this scope }
    flabel: lbp;            { list of labels in this scope }
    fconst: csp;            { list of constants in this scope }
    fstruct: stp;           { list of structures in this scope }
    occur: where;           { type of scope: blck, crec, vrec, rec }
    define: boolean;        { whether this is a defining scope }
    { ... additional fields }
  end;

  top: disprange;           { current top of display }
  level: levrange;          { current lexical level }

Type Structures (stp):
----------------------
Types are represented by variant records based on `form`:
  - scalar: Enumeration types
  - subrange: Subrange of ordinal type
  - pointer: Pointer types
  - power: Set types
  - arrays/arrayc: Static and container arrays
  - records: Record types with field lists
  - files: File types
  - objects: Object types (Pascaline extension)

================================================================================
                         MEMORY MANAGEMENT (RECYCLING)
================================================================================

The parser uses a recycling system to track memory allocation and detect leaks.
This is critical for ensuring the symbol table is properly cleaned up.

Allocation Counters:
--------------------
  ctpcnt: integer;          { identifier record count }
  stpcnt: integer;          { structure record count }
  cspcnt: integer;          { constant record count }
  lbpcnt: integer;          { label record count }
  { ... other counters }

Allocation Procedures:
----------------------
  ininam(p: ctp)            { initialize identifier, increment ctpcnt }
  putnam(p: ctp)            { dispose identifier, decrement ctpcnt }
  putnams(p: ctp)           { dispose identifier BST (recursive) }

The putnams Procedure:
----------------------
  procedure putnams(p: ctp);
  begin
    if p <> nil then begin
      putnams(p^.llink);    { release left subtree }
      putnams(p^.rlink);    { release right subtree }
      if not p^.keep then putnam(p)  { release if not kept }
    end
  end;

The `keep` flag prevents disposal - used for parameters that belong to their
procedure/function entry rather than the current scope.

Block Teardown (putdsp):
------------------------
When a scope ends, putdsp releases all resources:

  procedure putdsp(var dr: disprec);
  begin
    putnams(dr.fname);      { dispose identifier tree }
    { dispose label list }
    { dispose constant list }
    { dispose structure list }
    { dispose module name }
    { dispose operator procedures }
  end;

Balance Checking:
-----------------
At program end, all counters should be zero. Non-zero values indicate leaks:

  if ctpcnt <> 0 then
    writeln('*** Error: identifier recycle balance: ', ctpcnt:1);

================================================================================
                           IDENTIFIER LOOKUP
================================================================================

The searchid procedure finds identifiers across all scopes:

  procedure searchid(fidcls: setofids; var fcp: ctp);

Search order:
1. Current scope's BST (display[top].fname)
2. Enclosing scopes (display[top-1] down to display[0])
3. Module pile (for qualified module.identifier references)

When an identifier is found in an outer scope (disx <> top) within a defining
block, an alias is created:

  if (disx <> top) and (display[top].define) and not pdf then begin
    { downlevel, create an alias and link to bottom }
    new(lcp1, alias); ininam(lcp1); lcp1^.klass := alias;
    lcp1^.name := lcp^.name; lcp1^.actid := lcp;
    enterid(lcp1)
  end

This ensures the outer-scope identifier is accessible via local BST lookup.

================================================================================
                              FILE STRUCTURE
================================================================================

Lines 1-99:       Header comments, licensing, authors
Lines 100-110:    Program header, joins/uses clauses
Lines 112-260:    Constants
Lines 262-420:    Type definitions
Lines 422-530:    Variable declarations
Lines 532-730:    String handling utilities
Lines 730-970:    Memory management (ininam, putnam, putnams, putdsp)
Lines 970-1040:   Bitwise operations (bnot, bor, band, bxor)
Lines 1040-1545:  Error handling, input processing
Lines 1546-1987:  Lexical analyzer (insymbol)
Lines 1988-2400:  Symbol table management (enterid, searchid)
Lines 2400-3190:  Label and constant management
Lines 3190-4450:  Type utilities, compatibility checking
Lines 4450-4925:  Expression parsing
Lines 4926-6488:  Declaration parsing
Lines 6488-7080:  Statement parsing (body, statement)
Lines 7080-7750:  Module and external handling
Lines 7750-8100:  Standard identifier initialization
Lines 8100-8241:  Main program

================================================================================
                           KEY PROCEDURES
================================================================================

Lexical Analysis:
  insymbol          - Main scanner, sets sy/op/id/val globals

Symbol Table:
  enterid           - Insert identifier into current scope
  searchid          - Find identifier across all scopes
  searchidne        - Search without error on not found
  searchsection     - Search single scope (for record fields)

Memory Management:
  ininam            - Allocate and initialize identifier
  putnam            - Dispose single identifier
  putnams           - Dispose identifier tree
  putdsp            - Dispose entire scope (block teardown)
  putdsps           - Dispose multiple scopes

Parsing:
  modulep           - Top-level program/module parsing
  block             - Parse block (declarations + body)
  body              - Parse statement part
  statement         - Parse single statement
  expression        - Parse expression

Type Checking:
  comptypes         - Check type compatibility
  assigncompat      - Check assignment compatibility
  getbounds         - Get bounds of ordinal type

================================================================================
                          DEBUGGING OPTIONS
================================================================================

Command-line options for debugging:

  -l    List source with line numbers and ctp counts
  -r    Print recycling tracking counts at end
  -d    Dump display stack
  -b    Dump labels

The -l option shows ctp count at statement boundaries, useful for tracking
identifier leaks:

     1       -8 program test;
     2       -8 var x: integer;
     3       -8 begin
     4        3 end.
  ctp count: 170

The -r option shows final recycling counters to verify all memory was freed.

================================================================================
                              COMMON ISSUES
================================================================================

Recycle Balance Errors:
-----------------------
When ctpcnt is non-zero at program end, identifiers were allocated but not
freed. Common causes:

1. Setting keep := true incorrectly (prevents putnams from freeing)
2. Losing track of identifiers by not entering them in a scope
3. Not calling putdsp/putdsps at block end

See doc/recycle_debug.txt for debugging methodology.

Alias Handling:
---------------
Aliases are created when referencing outer-scope identifiers from nested scopes.
Key invariants:

1. Alias shares name pointer with original: lcp1^.name := lcp^.name
2. Alias has actid pointing to original: lcp1^.actid := lcp
3. Original is NOT marked with keep (would cause leak)
4. Alias is disposed when scope ends, original remains in its scope

Alias Lifetime Invariant:
-------------------------
Aliases are always created in inner scopes, while originals exist in outer
scopes. Block teardown processes inner scopes before outer scopes (putdsps
iterates from top downward). This guarantees:

  - Aliases are always freed BEFORE the identifiers they reference
  - The original identifier is valid for the entire lifetime of the alias
  - No keep flag is needed on the original - scope ordering provides safety

This is why setting keep := true on the original is wrong: it's unnecessary
(the original naturally outlives the alias) and causes memory leaks (the
original never gets freed).

"Downlevel" References:
-----------------------
When searchid finds an identifier and disx <> top, the identifier was found
in an outer scope (disx is the display level where it was found, top is the
current scope level). In a defining block (display[top].define = true), this
triggers alias creation:

  if (disx <> top) and (display[top].define) and not pdf then begin
    { downlevel, create an alias and link to bottom }
    new(lcp1, alias); ininam(lcp1); lcp1^.klass := alias;
    lcp1^.name := lcp^.name; lcp1^.actid := lcp;
    enterid(lcp1)
  end

Display vs Pile:
----------------
  - Display: Stack of lexical scopes within the current program/module.
    Indexed by `top`, contains identifier BSTs for each nesting level.

  - Pile: Array of module entries for cross-module references.
    Used when resolving qualified names (module.identifier).
    Indexed by `ptop`.

Block teardown uses putdsp for display entries, putpile for the pile.

Name Pointer Sharing:
---------------------
In parser.pas, aliases share the name pointer with the original:

  lcp1^.name := lcp^.name;  { alias points to same string }

This means:
  - The alias does NOT own its name string
  - disposestr must skip aliases: if p^.klass <> alias then disposestr(p^.name)
  - Only the original identifier frees the shared name string

If a derived tool copies the name instead (strcopy), it must also adjust
the disposal logic to free the alias's copy.

================================================================================
                      COMMON PITFALLS WHEN DERIVING
================================================================================

When creating tools derived from parser (like p2c), avoid these mistakes:

1. Adding keep := true flags
   - Don't add keep flags to "protect" identifiers from premature disposal
   - Understand the lifetime relationship first - it's usually already safe
   - Keep flags cause identifiers to never be freed (memory leaks)

2. Changing name handling without adjusting disposal
   - If you copy name strings instead of sharing, update disposestr logic
   - If aliases get their own names, they must be disposed

3. Adding defensive nil checks
   - if p <> nil or if p^.actid <> nil checks may hide real bugs
   - Understand WHY the pointer might be nil before adding guards
   - These often mask problems that will resurface elsewhere

4. Not comparing with parser.pas
   - When debugging, always test the same input on parser.pas first
   - If parser works but your tool doesn't, the bug is in your additions
   - Use diff/grep to find what you changed in the relevant sections

================================================================================
                              REFERENCES
================================================================================

1. source/pcom_theops.txt - Full compiler theory of operations
2. doc/recycle_debug.txt - Debugging identifier recycle balance errors
3. "Pascal Implementation" by Pemberton and Daniels (ISBN 0-13-653-0311)

================================================================================

Debugging Identifier Recycle Balance Errors
===========================================

When parser reports "identifier recycle balance: N", it means N
identifier records (ctps) were allocated via ininam but never freed via
putnam. This indicates a memory accounting leak.

Methodology
-----------

1. START WITH FACTS, NOT FIXES

   Analysis starts with observations about what is happening. Do not attempt
   quick fixes - they often treat symptoms and create new problems.

2. ESTABLISH A BASELINE

   Use the -l flag to see ctp counts during parsing:

       source/parser test -l

   This shows ctp count at the start of each statement. The count after
   parsing system symbols (around 168-171) is the baseline.

3. CREATE A MINIMAL TEST CASE

   Reduce the failing program to the smallest case that reproduces the error:

       program test;
       begin
       end.

   If this has no error, add back elements one at a time:

       program test;
       var x: integer;
       begin
       end.

   When the error appears, you've found the minimal causality.

4. DIFF THE RELEVANT SECTIONS

   Focus on:
   - Block teardown (putdsp, putnams, putdsps)
   - Identifier allocation (ininam calls)
   - The keep flag (prevents disposal in putnams)
   - Alias creation and disposal

5. UNDERSTAND LIFETIMES

   Before adding defensive code like:
   - keep := true (prevents disposal)
   - if p <> nil checks
   - if p^.actid <> nil checks

   First understand WHY a pointer might be nil or invalid. These guards
   often mask the real problem and create new ones.

Example Session
---------------

Problem: A tool derived from parser (e.g., p2c) reports "identifier recycle
balance: 3" on roman.pas, but parser itself has no error.

Step 1: Establish baseline
    $ source/parser test -l     # minimal program, ctp count = 168, no error

Step 2: Add variable declaration
    $ source/parser test -l     # with "var x: integer;", still no error

Step 3: Compare derived tool with parser
    $ utils/p2c test -l         # same program, balance error = 1

Conclusion: The bug is in code that the derived tool added, not in parser.

Step 4: Search for differences
    $ grep -n "keep := true" source/parser.pas utils/p2c.pas

Finding: The derived tool has extra "lcp^.keep := true" when creating aliases
that parser doesn't have. This prevents the original identifier from being
freed.

Key Lesson
----------

"Treating the symptom not the cause" - adding guards and flags to make
crashes stop without understanding why they happen creates new bugs.
Each band-aid fix can cause additional problems. Always analyze the
root cause first.
