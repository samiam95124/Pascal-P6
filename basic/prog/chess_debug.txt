Chess Game Debug Notes for IP Basic
=====================================
Last updated: 2026-02-18

STATUS
------
chess.bas is playable. The game loads, draws the board with ANSI colored ASCII
art pieces, accepts a color choice (W/B), and plays a full game. Tested through
4+ move exchanges as both White and Black. The computer's alpha-beta search at
depth 3 works correctly, including captures and piece development. Move
validation correctly rejects illegal moves (including when in check). Check
detection works (tested: computer gave check, human's non-blocking move was
rejected as illegal).

The binary must be rebuilt after source changes: the stale binary from before
PR #381 still had the sdim bug.

KNOWN REMAINING ISSUES
---------------------
The following have NOT been tested through actual gameplay:
- Castling (code exists but no game reached a castling position)
- En passant capture (code exists but no game triggered it)
- Pawn promotion (code exists but no game reached 8th rank)
- Checkmate detection (checkend% exists but no game reached checkmate)
- Stalemate detection (checkend% handles it but no game reached stalemate)
These are all coded and structurally correct but await interactive testing.

BUGS FIXED (in chess.bas)
-------------------------
5. findch% string indexing error on empty/exhausted input:
   - Root cause: IP Basic's `and` does NOT short-circuit (same as Pascal).
     `while i% <= len(s$) and mid$(s$, i%, 1) <> c$` evaluates BOTH sides
     even when `i% > len(s$)`, causing `mid$` to index past string end.
   - Fix: Use a flag variable to avoid the out-of-bounds access:
     ```
     while i% <= len(s$) and f% = 0
         if mid$(s$, i%, 1) = c$ then f% = 1 else i% = i% + 1
     wend
     ```

BUGS FIXED (in basic.pas, merged to master)
--------------------------------------------
1. sif/cansif bug ("No if is active" at endif):
   - Root cause: sif pushed ctif with sif=true BEFORE evaluating the condition
     expression. Function calls in the expression (via parfnc -> execl) would
     have endfunc do goto 2 -> cansif, which pops ALL ctif(sif=true) from the
     top of the control stack -- including the CALLER's ctif.
   - Fix: Initialize ctif with sif=false during expression evaluation (line
     5536), then set sif=true only at confirmed single-line exit paths (lines
     5568, 5586, 5593, 5604, 5625).
   - This bug was triggered by checkend%'s "if islegal%(...) = 1 then" because
     islegal% calls gmfr%/gmfc%/gmtr%/gmtc% accessor functions, and their
     endfunc triggers cansif.

2. sdim bug (multi-dimensional string arrays like dim pa$(6,4)):
   - Three issues: checked intv instead of strv for already-allocated test,
     off-by-one in index count (y-1 should be y), wrong threshold for vector
     type (y>2 should be y>1).
   - Lines ~7101-7107 in basic.pas.

3. Control stack save in function frames:
   - Added ctl:ctlptr field to fnsrec (line 266).
   - pshfns saves ctlstk (line 516).
   - Semicolon fix in pshfns (line 515).

4. Reserved word conflict in chess.bas:
   - "to" is a BASIC keyword (for...to loops). The local variable "to$" in
     getmove caused "Variable expected". Renamed to "dest$".

EARLIER BUGS FIXED (in previous sessions, also on master)
---------------------------------------------------------
- Empty parentheses on parameterless procedure calls
- Multiple endfunc in function bodies
- skpif couldn't skip over while/wend or for/next inside if/endif
- Label names longer than 12 chars caused errors
- goto out of if/endif blocks corrupted the control stack
- Nil pointer dereference in popctl during control stack purging

HOW TO BUILD AND RUN
--------------------
Compile interpreter (from project root):
  bin/pc basic/basic

Run chess game interactively:
  cd basic && ./basic
  load "prog/chess"
  run

Run with piped input for testing (as Black, 3 moves):
  cd basic
  printf 'load "prog/chess"\nrun\nb\n\n\n2,5 4,5\n\n2,4 4,4\n\n1,2 3,3\n\n' | timeout 300 ./basic

Capture trace output:
  Add "trace" before the suspect line in chess.bas, then:
  printf 'load "prog/chess"\nrun\nw\n' | ./basic 2>&1 | tee /tmp/chess_trace.txt

KEY FILES
---------
basic/basic.pas        - IP Basic interpreter source (Pascal)
basic/prog/chess.bas   - Chess game source (~1028 lines)
basic/basic            - Compiled interpreter binary
doc/basic.odt          - IP Basic language reference

CHESS.BAS STRUCTURE
-------------------
Lines 1-50:     Global variables, escape code strings, piece encoding constants
Lines 51-120:   DATA statements for ASCII art pieces (6 types x 4 rows)
Lines 121-170:  Piece art loading, utility procedures (cls, moveto, resetcol)
Lines 162-170:  findch% helper function (find char in string)
Lines 219-301:  drawboard procedure (ANSI colored ASCII art board display)
Lines 307-351:  Move accessor functions (gmfr%, gmfc%, gmtr%, gmtc%)
Lines 357-500:  genmoves procedure (pseudo-legal move generation for all pieces)
Lines 506-569:  incheck% function (checks if a side's king is attacked)
Lines 575-646:  makemove procedure (execute move with special move handling)
Lines 652-686:  unmake procedure (reverse a move)
Lines 692-698:  islegal% function (make/check/unmake wrapper)
Lines 704-748:  evaluate% function (material + positional scoring)
Lines 805-849:  compmove procedure (alpha-beta search, depth 3)
Lines 855-932:  getmove procedure (human move input and validation)
Lines 938-955:  checkend% function (checkmate/stalemate detection)
Lines 960-988:  initboard, game setup, color choice
Lines 990-1028: Main game loop

IP BASIC GOTCHAS
----------------
- "to" is a reserved word (for...to). Don't use as variable name.
- IP Basic's `and`/`or` does NOT short-circuit. Both operands are always
  evaluated. Avoid array/string indexing in while conditions -- use a flag
  variable instead (same fix as for Pascal).
- Max 255 variables total. Chess.bas uses many; be careful adding more.
- Strings max 250 chars.
- No built-in terminal control -- use raw ANSI escapes via chr$(27).
- goto inside multiline if/endif can corrupt control stack (fixed in
  interpreter, but best avoided in BASIC code -- use single-line
  "if cond then goto label" pattern instead).
- Function calls in if-condition expressions are now safe (fixed), but
  were the source of the major bug.
- Arrays are sparse and auto-dimensioned.
- Case insensitive.
- Binary must be rebuilt after basic.pas changes (stale binary was the
  cause of the initial "Wrong number of demensions" error).

DEBUGGING TIPS
--------------
- "trace" statement in BASIC turns on line-by-line trace output
- "stop" statement halts execution at that point
- Use tee to capture output: ./basic 2>&1 | tee /tmp/output.txt
- prterr in basic.pas prints curprg (current line) BEFORE the error
  message, so trace output may show a line twice -- the second occurrence
  is prterr's diagnostic print, not actual re-execution.
- Key interpreter procedures to understand:
  - execl (line 3446): main execution loop, labels 1 and 2
  - stat (line 3455): statement dispatcher, nested inside execl
  - sif (line 5528): if statement handler
  - cansif (line 692): cancels single-line if entries on control stack
  - parfnc (line 3570): function/procedure call mechanism
  - pshctl/popctl: control stack push/pop
  - pshfns/popfns: function frame push/pop
